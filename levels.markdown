---
title: Levels
author: Carl Mäsak
created: 2010-04-14T16:04:00+02:00
---
- First, you find the **tool** and find that it does a lot of good for you. The tool might be `perl`, an executable, or Perl, a language family. You engage in a positive cycle where learning more provides you with a more means to solve new problems efficiently.
- Then, you find the **repository**. In the case of Perl, that's CPAN. It's full of code that solves problems, including problems you've been trying to solve lately. It's like finding a cave full of treasures. The tool becomes immeasurably richer because of the repository.
- Then, you find the **patterns**. Those are recurring code idioms within your solutions, and within the solutions in the repository. Usually they encode common sense, and represent which configurations survived in the human-assisted natural selection occurring when solutions grow and change. You discover that the range of solutions you're able to solve satisfactorily increases as you master the various patterns.
- Finally, you find the **community**. After all this time enjoying the tool, the repository, and the patterns, you connect with the group of people behind some of these. The group of people forms an intangible but very real resource in itself; people share knowledge freely in the ad-hoc network that forms and reshapes itself.

The above list is of course idealized, and the events must not occur that clearly or in that order. The world is messy, and it's possible to 'level up' according to a very personalized path, and with vastly different speeds.

An interesting effect is that whereas it's more straightforward for beginners to access the levels in the order stated above, the reverse holds for *contributing* to the different levels. You're more likely to push something to CPAN than to patch the `perl` compiler, and contributing to the community is something you do just by submerging yourself in it.

Because the first three levels are completely dead and consist only of ones and zeros, it's easy to forget that one is dealing with humans at all. One might stumble into the community layer with a dead-things mindset, and say things that wouldn't be acceptable if they didn't take place on the Internet, where expectations are that everyone might be a jerk.

Far too often, I see tweets on this form:

<div class='quote'><p>People who [engage in practice X] should be {hanged, drawn and quartered | shot on sight | [etc]}</p></div>

That kind of rage is only possible when we forget both that practice X (for most values of X) is only configurations of ones and zeros, and that the people who engage in it are indivuduals just like us. Yes, it's hyperbole, and we don't mean actual shooting on sight — but the mere fact that we're casually formulating this thought is worrying. Or should be.

Zen Buddhism talks about the perceptible world being an illusion. As programmers, we *know* that we're dealing with castles built of virtual nothingness, and still we are prepared to lose our temper over exactly how they're built. We get stuck sometimes in the illusion projected by our machines.

The community level is where the least amount of code gets written. From the perspective of programmer-minded problem solving, it's the most abstract and ephemeral level. From the point of view of people, places, and things, it's the only level that actually exists. If all the other levels went away but the community remained, we could still do great things. If all the other levels remained but the community went away, there'd be no-one left to notice.


